/***** AUTOGENERATED *****/

ENTRY(Reset_Handler)

/* overridable constants */
__stack_min              = DEFINED(__stack_min) ? __stack_min : 0x00001000;
__heap_min               = DEFINED(__heap_min) ? __heap_min : 0x00001000;

MEMORY {
    FLASH            (RX ) : ORIGIN = 0x00000000, LENGTH = 0x000fa000
    RAM              (RW ) : ORIGIN = 0x20000000, LENGTH = 0x00034000
}

SECTIONS {
    /* FLASH sections */
    .isr_vector : {
        . = ALIGN(4);
        __isr_vector = .;
        KEEP(*(.isr_vector))
        . = __isr_vector + 0x400;
        . = ALIGN(4);
        __isr_vector_end = .;
    } > FLASH

    .text : {
        . = ALIGN(4);
        __text = .;
        *(.text*)
        *(.rodata*)
        *(.glue_7*)
        *(.glue_7t*)
        *(.eh_frame*)
        KEEP(*(.init*))
        KEEP(*(.fini*))
        . = ALIGN(4);
        __text_end = .;
        __data_init = .;
    } > FLASH

    /* RAM sections */
    .stack (NOLOAD) : {
        . = ALIGN(4);
        __stack = .;
    } > RAM
    . += __stack_min;
    . = ALIGN(4);
    __stack_end = .;

    .data : AT(__data_init) {
        . = ALIGN(4);
        __data = .;
        *(.data*)
        . = ALIGN(4);
        __data_end = .;
    } > RAM

    .bss (NOLOAD) : {
        . = ALIGN(4);
        __bss = .;
        __bss_start__ = .;
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        __bss_end = .;
        __bss_end__ = .;
    } > RAM

    .heap (NOLOAD) : {
        . = ALIGN(4);
        __end__ = .;
        PROVIDE(end = .);
        __heap = .;
        __HeapBase = .;
    } > RAM
    . += ORIGIN(RAM) + LENGTH(RAM);
    . = ALIGN(4);
    __heap_end = .;
    __HeapLimit = .;
    __heap_limit = .;
    ASSERT(__heap_end - __heap > __heap_min,
        "Not enough memory for heap")
}

